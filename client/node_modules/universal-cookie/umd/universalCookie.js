(function (global, factory) {
	typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory() :
	typeof define === 'function' && define.amd ? define(factory) :
	(global = typeof globalThis !== 'undefined' ? globalThis : global || self, global.UniversalCookie = factory());
})(this, (function () { 'use strict';

	function getDefaultExportFromCjs (x) {
		return x && x.__esModule && Object.prototype.hasOwnProperty.call(x, 'default') ? x['default'] : x;
	}

	var cjs = {};

	var Cookies = {exports: {}};

	var cookie$1 = {};

	/*!
	 * cookie
	 * Copyright(c) 2012-2014 Roman Shtylman
	 * Copyright(c) 2015 Douglas Christopher Wilson
	 * MIT Licensed
	 */

	/**
	 * Module exports.
	 * @public
	 */

	cookie$1.parse = parse;
	cookie$1.serialize = serialize;

	/**
	 * Module variables.
	 * @private
	 */

	var __toString = Object.prototype.toString;

	/**
	 * RegExp to match field-content in RFC 7230 sec 3.2
	 *
	 * field-content = field-vchar [ 1*( SP / HTAB ) field-vchar ]
	 * field-vchar   = VCHAR / obs-text
	 * obs-text      = %x80-FF
	 */

	var fieldContentRegExp = /^[\u0009\u0020-\u007e\u0080-\u00ff]+$/;

	/**
	 * Parse a cookie header.
	 *
	 * Parse the given cookie header string into an object
	 * The object has the various cookies as keys(names) => values
	 *
	 * @param {string} str
	 * @param {object} [options]
	 * @return {object}
	 * @public
	 */

	function parse(str, options) {
	  if (typeof str !== 'string') {
	    throw new TypeError('argument str must be a string');
	  }

	  var obj = {};
	  var opt = options || {};
	  var dec = opt.decode || decode;

	  var index = 0;
	  while (index < str.length) {
	    var eqIdx = str.indexOf('=', index);

	    // no more cookie pairs
	    if (eqIdx === -1) {
	      break
	    }

	    var endIdx = str.indexOf(';', index);

	    if (endIdx === -1) {
	      endIdx = str.length;
	    } else if (endIdx < eqIdx) {
	      // backtrack on prior semicolon
	      index = str.lastIndexOf(';', eqIdx - 1) + 1;
	      continue
	    }

	    var key = str.slice(index, eqIdx).trim();

	    // only assign once
	    if (undefined === obj[key]) {
	      var val = str.slice(eqIdx + 1, endIdx).trim();

	      // quoted values
	      if (val.charCodeAt(0) === 0x22) {
	        val = val.slice(1, -1);
	      }

	      obj[key] = tryDecode(val, dec);
	    }

	    index = endIdx + 1;
	  }

	  return obj;
	}

	/**
	 * Serialize data into a cookie header.
	 *
	 * Serialize the a name value pair into a cookie string suitable for
	 * http headers. An optional options object specified cookie parameters.
	 *
	 * serialize('foo', 'bar', { httpOnly: true })
	 *   => "foo=bar; httpOnly"
	 *
	 * @param {string} name
	 * @param {string} val
	 * @param {object} [options]
	 * @return {string}
	 * @public
	 */

	function serialize(name, val, options) {
	  var opt = options || {};
	  var enc = opt.encode || encode;

	  if (typeof enc !== 'function') {
	    throw new TypeError('option encode is invalid');
	  }

	  if (!fieldContentRegExp.test(name)) {
	    throw new TypeError('argument name is invalid');
	  }

	  var value = enc(val);

	  if (value && !fieldContentRegExp.test(value)) {
	    throw new TypeError('argument val is invalid');
	  }

	  var str = name + '=' + value;

	  if (null != opt.maxAge) {
	    var maxAge = opt.maxAge - 0;

	    if (isNaN(maxAge) || !isFinite(maxAge)) {
	      throw new TypeError('option maxAge is invalid')
	    }

	    str += '; Max-Age=' + Math.floor(maxAge);
	  }

	  if (opt.domain) {
	    if (!fieldContentRegExp.test(opt.domain)) {
	      throw new TypeError('option domain is invalid');
	    }

	    str += '; Domain=' + opt.domain;
	  }

	  if (opt.path) {
	    if (!fieldContentRegExp.test(opt.path)) {
	      throw new TypeError('option path is invalid');
	    }

	    str += '; Path=' + opt.path;
	  }

	  if (opt.expires) {
	    var expires = opt.expires;

	    if (!isDate(expires) || isNaN(expires.valueOf())) {
	      throw new TypeError('option expires is invalid');
	    }

	    str += '; Expires=' + expires.toUTCString();
	  }

	  if (opt.httpOnly) {
	    str += '; HttpOnly';
	  }

	  if (opt.secure) {
	    str += '; Secure';
	  }

	  if (opt.priority) {
	    var priority = typeof opt.priority === 'string'
	      ? opt.priority.toLowerCase()
	      : opt.priority;

	    switch (priority) {
	      case 'low':
	        str += '; Priority=Low';
	        break
	      case 'medium':
	        str += '; Priority=Medium';
	        break
	      case 'high':
	        str += '; Priority=High';
	        break
	      default:
	        throw new TypeError('option priority is invalid')
	    }
	  }

	  if (opt.sameSite) {
	    var sameSite = typeof opt.sameSite === 'string'
	      ? opt.sameSite.toLowerCase() : opt.sameSite;

	    switch (sameSite) {
	      case true:
	        str += '; SameSite=Strict';
	        break;
	      case 'lax':
	        str += '; SameSite=Lax';
	        break;
	      case 'strict':
	        str += '; SameSite=Strict';
	        break;
	      case 'none':
	        str += '; SameSite=None';
	        break;
	      default:
	        throw new TypeError('option sameSite is invalid');
	    }
	  }

	  return str;
	}

	/**
	 * URL-decode string value. Optimized to skip native call when no %.
	 *
	 * @param {string} str
	 * @returns {string}
	 */

	function decode (str) {
	  return str.indexOf('%') !== -1
	    ? decodeURIComponent(str)
	    : str
	}

	/**
	 * URL-encode value.
	 *
	 * @param {string} str
	 * @returns {string}
	 */

	function encode (val) {
	  return encodeURIComponent(val)
	}

	/**
	 * Determine if value is a Date.
	 *
	 * @param {*} val
	 * @private
	 */

	function isDate (val) {
	  return __toString.call(val) === '[object Date]' ||
	    val instanceof Date
	}

	/**
	 * Try decoding a string using a decoding function.
	 *
	 * @param {string} str
	 * @param {function} decode
	 * @private
	 */

	function tryDecode(str, decode) {
	  try {
	    return decode(str);
	  } catch (e) {
	    return str;
	  }
	}

	var utils = {};

	Object.defineProperty(utils, "__esModule", {
	  value: true
	});
	utils.cleanCookies = cleanCookies;
	utils.hasDocumentCookie = hasDocumentCookie;
	utils.parseCookies = parseCookies;
	utils.readCookie = readCookie;
	var cookie = _interopRequireWildcard(cookie$1);
	function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
	function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
	function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
	function hasDocumentCookie() {
	  // Can we get/set cookies on document.cookie?
	  return (typeof document === "undefined" ? "undefined" : _typeof(document)) === 'object' && typeof document.cookie === 'string';
	}
	function cleanCookies() {
	  document.cookie.split(';').forEach(function (c) {
	    document.cookie = c.replace(/^ +/, '').replace(/=.*/, '=;expires=' + new Date().toUTCString() + ';path=/');
	  });
	}
	function parseCookies(cookies) {
	  if (typeof cookies === 'string') {
	    return cookie.parse(cookies);
	  } else if (_typeof(cookies) === 'object' && cookies !== null) {
	    return cookies;
	  } else {
	    return {};
	  }
	}
	function readCookie(value) {
	  var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
	  var cleanValue = cleanupCookieValue(value);
	  if (!options.doNotParse) {
	    try {
	      return JSON.parse(cleanValue);
	    } catch (e) {
	      // At least we tried
	    }
	  }
	  // Ignore clean value if we failed the deserialization
	  // It is not relevant anymore to trim those values
	  return value;
	}
	function cleanupCookieValue(value) {
	  // express prepend j: before serializing a cookie
	  if (value && value[0] === 'j' && value[1] === ':') {
	    return value.substr(2);
	  }
	  return value;
	}

	(function (module, exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		exports["default"] = void 0;
		var cookie = _interopRequireWildcard(cookie$1);
		var _utils = utils;
		function _getRequireWildcardCache(nodeInterop) { if (typeof WeakMap !== "function") return null; var cacheBabelInterop = new WeakMap(); var cacheNodeInterop = new WeakMap(); return (_getRequireWildcardCache = function _getRequireWildcardCache(nodeInterop) { return nodeInterop ? cacheNodeInterop : cacheBabelInterop; })(nodeInterop); }
		function _interopRequireWildcard(obj, nodeInterop) { if (!nodeInterop && obj && obj.__esModule) { return obj; } if (obj === null || _typeof(obj) !== "object" && typeof obj !== "function") { return { "default": obj }; } var cache = _getRequireWildcardCache(nodeInterop); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (key !== "default" && Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj["default"] = obj; if (cache) { cache.set(obj, newObj); } return newObj; }
		function _typeof(o) { "@babel/helpers - typeof"; return _typeof = "function" == typeof Symbol && "symbol" == typeof Symbol.iterator ? function (o) { return typeof o; } : function (o) { return o && "function" == typeof Symbol && o.constructor === Symbol && o !== Symbol.prototype ? "symbol" : typeof o; }, _typeof(o); }
		function _defineProperty(obj, key, value) { key = _toPropertyKey(key); if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }
		function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }
		function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, _toPropertyKey(descriptor.key), descriptor); } }
		function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); Object.defineProperty(Constructor, "prototype", { writable: false }); return Constructor; }
		function _toPropertyKey(arg) { var key = _toPrimitive(arg, "string"); return _typeof(key) === "symbol" ? key : String(key); }
		function _toPrimitive(input, hint) { if (_typeof(input) !== "object" || input === null) return input; var prim = input[Symbol.toPrimitive]; if (prim !== undefined) { var res = prim.call(input, hint || "default"); if (_typeof(res) !== "object") return res; throw new TypeError("@@toPrimitive must return a primitive value."); } return (hint === "string" ? String : Number)(input); }
		var Cookies = /*#__PURE__*/function () {
		  function Cookies(cookies) {
		    var _this = this;
		    var defaultSetOptions = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		    _classCallCheck(this, Cookies);
		    this.changeListeners = [];
		    this.HAS_DOCUMENT_COOKIE = false;
		    this.update = function () {
		      if (!_this.HAS_DOCUMENT_COOKIE) {
		        return;
		      }
		      var previousCookies = _this.cookies;
		      _this.cookies = cookie.parse(document.cookie);
		      _this._checkChanges(previousCookies);
		    };
		    var domCookies = typeof document === 'undefined' ? '' : document.cookie;
		    this.cookies = (0, _utils.parseCookies)(cookies || domCookies);
		    this.defaultSetOptions = defaultSetOptions;
		    this.HAS_DOCUMENT_COOKIE = (0, _utils.hasDocumentCookie)();
		  }
		  _createClass(Cookies, [{
		    key: "_emitChange",
		    value: function _emitChange(params) {
		      for (var i = 0; i < this.changeListeners.length; ++i) {
		        this.changeListeners[i](params);
		      }
		    }
		  }, {
		    key: "_checkChanges",
		    value: function _checkChanges(newCookies) {
		      var _this2 = this;
		      var names = new Set(Object.keys(newCookies).concat(Object.keys(this.cookies)));
		      names.forEach(function (name) {
		        if (newCookies[name] !== _this2.cookies[name]) {
		          _this2._emitChange({
		            name: name,
		            value: (0, _utils.readCookie)(newCookies[name])
		          });
		        }
		      });
		    }
		  }, {
		    key: "_startPolling",
		    value: function _startPolling() {
		      this.pollingInterval = setInterval(this.update, 300);
		    }
		  }, {
		    key: "_stopPolling",
		    value: function _stopPolling() {
		      if (this.pollingInterval) {
		        clearInterval(this.pollingInterval);
		      }
		    }
		  }, {
		    key: "get",
		    value: function get(name) {
		      var options = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
		      if (!options.doNotUpdate) {
		        this.update();
		      }
		      return (0, _utils.readCookie)(this.cookies[name], options);
		    }
		  }, {
		    key: "getAll",
		    value: function getAll() {
		      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
		      if (!options.doNotUpdate) {
		        this.update();
		      }
		      var result = {};
		      for (var name in this.cookies) {
		        result[name] = (0, _utils.readCookie)(this.cookies[name], options);
		      }
		      return result;
		    }
		  }, {
		    key: "set",
		    value: function set(name, value, options) {
		      if (options) {
		        options = Object.assign(Object.assign({}, this.defaultSetOptions), options);
		      } else {
		        options = this.defaultSetOptions;
		      }
		      var stringValue = typeof value === 'string' ? value : JSON.stringify(value);
		      this.cookies = Object.assign(Object.assign({}, this.cookies), _defineProperty({}, name, stringValue));
		      if (this.HAS_DOCUMENT_COOKIE) {
		        document.cookie = cookie.serialize(name, stringValue, options);
		      }
		      this._emitChange({
		        name: name,
		        value: value,
		        options: options
		      });
		    }
		  }, {
		    key: "remove",
		    value: function remove(name, options) {
		      var finalOptions = options = Object.assign(Object.assign({}, options), {
		        expires: new Date(1970, 1, 1, 0, 0, 1),
		        maxAge: 0
		      });
		      this.cookies = Object.assign({}, this.cookies);
		      delete this.cookies[name];
		      if (this.HAS_DOCUMENT_COOKIE) {
		        document.cookie = cookie.serialize(name, '', finalOptions);
		      }
		      this._emitChange({
		        name: name,
		        value: undefined,
		        options: options
		      });
		    }
		  }, {
		    key: "addChangeListener",
		    value: function addChangeListener(callback) {
		      this.changeListeners.push(callback);
		      if (this.changeListeners.length === 1) {
		        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && 'cookieStore' in window) {
		          window.cookieStore.addEventListener('change', this.update);
		        } else {
		          this._startPolling();
		        }
		      }
		    }
		  }, {
		    key: "removeChangeListener",
		    value: function removeChangeListener(callback) {
		      var idx = this.changeListeners.indexOf(callback);
		      if (idx >= 0) {
		        this.changeListeners.splice(idx, 1);
		      }
		      if (this.changeListeners.length === 0) {
		        if ((typeof window === "undefined" ? "undefined" : _typeof(window)) === 'object' && 'cookieStore' in window) {
		          window.cookieStore.removeEventListener('change', this.update);
		        } else {
		          this._stopPolling();
		        }
		      }
		    }
		  }]);
		  return Cookies;
		}();
		exports["default"] = Cookies;
		module.exports = exports.default; 
	} (Cookies, Cookies.exports));

	var CookiesExports = Cookies.exports;

	var types = {};

	Object.defineProperty(types, "__esModule", {
	  value: true
	});

	(function (exports) {

		Object.defineProperty(exports, "__esModule", {
		  value: true
		});
		var _exportNames = {};
		exports["default"] = void 0;
		var _Cookies = _interopRequireDefault(CookiesExports);
		var _types = types;
		Object.keys(_types).forEach(function (key) {
		  if (key === "default" || key === "__esModule") return;
		  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;
		  if (key in exports && exports[key] === _types[key]) return;
		  Object.defineProperty(exports, key, {
		    enumerable: true,
		    get: function get() {
		      return _types[key];
		    }
		  });
		});
		function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }
		var _default = _Cookies["default"];
		exports["default"] = _default; 
	} (cjs));

	var index = /*@__PURE__*/getDefaultExportFromCjs(cjs);

	return index;

}));
